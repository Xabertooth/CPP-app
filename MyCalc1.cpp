#include "std_lib_facilities.h"

//------------------------------------------------------------------------------------------------

class Token { //Класс для хранения и оперделения лексем
public:
	char kind;
	double value;
	Token(char ch): kind(ch), value(0){ }
	Token(char ch, double val): kind(ch), value(val){ }
};

//------------------------------------------------------------------------------------------------

class Token_stream { //Класс - поток лексем
public: //пользовательский интерфейс
	Token_stream(); //Создаёт объект класса Token_stream, считывающий данные из потока cin 
	Token get(); //Получает объект Token из потока 
	void putback(Token t); //Возвращает Token обратно в поток
private: //данные необходимые для реализации класса
	bool full {false}; //Наличие лексемы в буфере(исходно-нет)
	Token buffer; //Буфер для хранения лексемы после возврата с помощью putback()
};
//------------------------------------------------------------------------------------------------

Token_stream::Token_stream(): full(false), buffer(0){ } //Конструктор устанавливающий индикатор заполнения буфера в сост. false и создаёт пустой буфер

//------------------------------------------------------------------------------------------------

void Token_stream::putback(Token t){ //Определение функции putback()
	if (full) error("Буфер заполнен!");
	full = true; //Установка индикатора заполнения буфера в 1
	buffer = t;	//Копирование лексемы в буфер
}

//------------------------------------------------------------------------------------------------

Token Token_stream::get(){ //Oпределение функции get()
	if (full) //Если в буфере есть какая-то лексема, то возвращаем её
	{
		full = false;
		return buffer;
	}
	char ch;
	cin >> ch;
	
	switch(ch){
		case '=': //для вывода результата
		case 'x':
		case '(': case ')': case '+': case '-': case '*': case '/': case '{': case '}': case '!':
			return Token{ch};
		case '.':
		case '0': case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			{
				cin.putback(ch); //Возвращаем символ обратно в поток cin
				double val;
				cin >> val; //считываем число с плавающей точкой
				return Token{'8', val}; //возвращение лексемы "число" (об этом свидетельствует значение класса Token = '8') 
			}
		default:
			error("Неверная лексема");
	}
}

//------------------------------------------------------------------------------------------------

Token_stream ts; //Переменная типа Token_stream необходимая для представления функций get() & putback() класса Taken_stream

//------------------------------------------------------------------------------------------------

double expression(); //Объявление для использование в функции Primary()

//------------------------------------------------------------------------------------------------

double term(); //Объявление для использование в функции Primary()

//------------------------------------------------------------------------------------------------

int factorial(int x){ //функция для вычисления факториала
	if (x == 0) x = 1;
	int i = x;
	--i;
	while(i > 0){
		x *= i;
		--i;
	}
	return x;
}

//------------------------------------------------------------------------------------------------

double primary(){ //Функция для определиния первичного выражения (работа с числами и скобками)
	Token t = ts.get();
	switch(t.kind){
		case '(':
		{
			double d = expression();
			t = ts.get();
			if (t.kind != ')') 
			{
				error("требуется ')'");
			}
			return d;
		}
		case '{':
		{
			double c = term();
			t = ts.get();
			if (t.kind != '}') 
			{
				error("требуется '}'");
			}
			return c;
		}
		case '8': //Используем '8' для представления числа
			return t.value; //Возврат значения числа
		default:
			error("Требуется первичное выражение!");
	}
}

//------------------------------------------------------------------------------------------------

double term(){ //функция для определения терма (работа с * и /)
	double left = primary(); 
	Token t = ts.get(); 
	while(true)
	{
		switch(t.kind)
		{
			case '!': //факториал (прим. 7! = 7*6*5*4*3*2*1)
			{
				int x = left; //присваивание переменной х значение переменной left, для для приведения её к типу int
				left = factorial(x);
				t = ts.get();
				break;
			}
			case '*':
			{
				left *= primary();
				t = ts.get();
				break;
			}
			case '/':
			{
				double d = primary();
				if(d==0)
				{
					error("Деление на нуль");
				}
				left /= d;
				t = ts.get();
				break;
			}
			default:
			{
				ts.putback(t); //Возврат t в поток лексем;
				return left;
			}
		}
	}	
}

//------------------------------------------------------------------------------------------------

double expression(){
	double left = term(); //Считывание и вычисление Терма
	Token t = ts.get(); //получение лексемы
	while(true)
	{
		switch(t.kind)
		{
		case '+':
			left += term(); //вычисление и суммирование терма
			t = ts.get();
			break;
		case '-':
			left -= term();
			t = ts.get();
			break;
		default:
			ts.putback(t); //возврат t в поток лексем
			return left; //конец функции. если нет + или -, возвращаем ответ
		}
	}
}

//------------------------------------------------------------------------------------------------

int main()
try
{
	cout << "Добро пожаловать в программу-Супер калькулятор!\n"
		 << "Вводите выражения с числами с плавающей точкой.\n"
		 << "Для получения результата введте символ '='.\n"
		 << "Для выхода введите символ 'x'(икс).\n";
	double val = 0;
	while(cin){
		Token t = ts.get();
		if(t.kind == 'x') break;
		if(t.kind == '=') cout << "=" << val << '\n';
		else ts.putback(t);
		val = expression();
	}
	keep_window_open();
}
catch (exception& e) {
    cerr << "error: " << e.what() << '\n'; 
	keep_window_open();
    return 1;
}
catch (...) {
    cerr << "Oops: unknown exception!\n"; 
	keep_window_open();
    return 2;
}

//------------------------------------------------------------------------------------------------
